# HTTP

# HTTP

> 애플리케이션 계층에서 웹 서비스 통신에 사용
HTML 문서와 같은 리소스들을 가져올 수 있도록 해주는 프로토콜
> 
- 클라이언트-서버 프로토콜 = 수신자 측에 의해 요청이 초기화되는 프로토콜(stateless)
- 클라이언트는 서버에게 요청을, 서버는 클라이언트에게 요청에 대한 응답을 주어야 한다.

![Untitled](HTTP%20151d337544f54edd80838beb0a8b7ecf/Untitled.png)

- TCP or 암호화된 TCP 연결인 TLS를 통해 전송된다.

![Untitled](HTTP%20151d337544f54edd80838beb0a8b7ecf/Untitled%201.png)

## HTTP 기반 시스템 구성요소

클라이언트와 서버 간의 요청과 응답 사이에는 게이트웨이나 캐시 역할을 하는 프록시 등의 개체들이 있다.

![Untitled](HTTP%20151d337544f54edd80838beb0a8b7ecf/Untitled%202.png)

### 프록시의 기능

- 캐싱
- 필터링 (유해 컨텐츠 차단, 바이러스 백신 스캔)
- 로드 밸런싱 (여러 서버들에게 요청 분배)
- 인증 (다양한 리소스에 대한 접근 제어)
- 로깅 (이력 정보 저장)

## HTTP 개요

TCP 표준에 의존하여 클라이언트와 서버가 TCP 연결을 설정해야 한다. 

HTTP/1.0에서는 각 요청/응답에 대해 각각 TCP 연결을 했으나 효율적이지 못해, HTTP/1.1에서는 파이프라이닝 개념과 Connection 헤더 사용으로 이러한 결함을 부분적으로 제어할 수 있었다. HTTP/2.0은 단일 연결 상에서 메시지를 다중 전송할 수 있게 하였고, HTTP/3.0에서는 빠르고 효율적인 전송 프로토콜을 위해 UDP기반의 QUIC를 사용하고 있다.

HTTP로 

- 캐시
- 인증
- 세션

등을 제어할 수 있다.

## HTTP 흐름

1. TCP 연결
2. HTTP 메세지 전송.
    
    HTTP 메세지(HTTP/2.0 이전은 인간이 읽을 수 있다.)  HTTP/2.0에서는 프레임 속으로 캡슐화되어 직접 읽는게 불가능하다.
    
    ![Untitled](HTTP%20151d337544f54edd80838beb0a8b7ecf/Untitled%203.png)
    
3. 서버에 의한 전송된 응답을 읽어들인다.
    
    ![Untitled](HTTP%20151d337544f54edd80838beb0a8b7ecf/Untitled%204.png)
    
4. 연결을 닫거나 다른 요청을 위해 재사용한다.

HTTP 파이프라이닝이 활성화되면, 첫 번째 응답의 수신을 기다리지 않고 여러 요청을 보낼 수 있다. but, 네트워크 상에서 구현하기 어렵다는게 입증되어서, 프레임 안에서 활발하게 다중 요청을 보낼 수 있는 HTTP/2.0으로 교체되어가고 있다.

## HTTP/1.0 - 확장

> 한 연결당 하나의 요청을 처리
> 

초창기 웹은 문서 간의 연결을 위한 ‘하이퍼텍스트’를 위해 고안되었다. 따라서 HTTP/0.9에서는 GET메서드가 유일했다. 이에 웹을 확장하여 HTTP/1.0이 탄생하게 되었다.

### 개선 사항

- 버전 정보가 요청 안에 들어가게 되었다.
- 상태 라인 코드 또한 응답 시작 부분에 들어가, 브라우저가 요청에 대한 성공여부를 알 수 있게 되었다.
- HTTP 헤더 개념이 도입되어, 메타데이터 전송을 허용하고 프로토콜을 유연하게 만들어 주었다.
    
    Content-Type과 같은 개념의 도입으로 HTML 외 다른 문서들을 전송할 수 있게 되었다.
    

but, 한 요청/응답마다 TCP의 3-웨이 핸드쉐이크를 계속 발생시켜야 하기 때문에 RTT가 증가하는 문제가 발생한다. RTT가 증가함에 따라 서버에 부담이 가고, 사용자 응답 시간이 길어지게 되었다.

### 해결 방법

- **이미지 스플리팅**
    - 여러 이미지가 합쳐져 있는 하나의 이미지를 다운받고, background-image의 position으로 활용해서 이미지 표기
- **코드 압축**
    - 개행 문자, 빈칸을 없애서 코드 크기를 최소화
- **이미지 Base64 인코딩**
    - 이미지 파일을 64진법으로 이루어진 문자열로 인코딩하는 방법
        
        → 이 방법으로 이미지에 대해 서버와 HTTP 요청을 할 필요가 없지만, Base64 문자열로 변환할 경우 크기가 37% 정도 더 커진다.
        

## HTTP/1.1 - 표준 프로토콜

하나의 요청/응답을 위해 매번 TCP를 재연결해야 하는 HTTP/1.0의 불편함을 해소하고자 나왔다.

### 개선 사항

- 커넥션을 재사용할 수 있게 하여 시간을 절약한다.
- 파이프라이닝을 추가하여, 첫 번째 요청에 대한 응답이 완전히 전송되기 전에 두 번째 전송을 가능하게 한다.
- 청크된 응답을 지원한다.

but, HOL Blocking이나 헤더들을 추가해서 사용하다 보니 헤더가 무거워지는 문제점이 발생한다. 

### 문제점

- HOL Blocking (Head Of Line Blocking)
    
    네트워크에서 같은 큐에 있는 패킷이 그 첫 번째 패킷에 의해 지연될 때 발생하는 성능 저하 현상
    
- 무거운 헤더 구조
    
    쿠키와 같은 메타데이터가 압축이 되지 않은 채 들어와 무거워졌다.
    

## HTTP/2.0 - 더 나은 성능을 위한 프로토콜

웹 페이지도 발전함에 따라 복잡해지면서 미디어, 스크립트의 양과 크기가 방대해졌다. HTTP/1.1은 올바른 순서대로 전송되는 요청이 필요하기에 병렬 커넥션을 사용 가능한 경우, 여전히 오버헤드와 복잡도가 문제가 되었다. 

그래서 2010년 Google은 SPDY 프로토콜을 구현하여, 클라이언트와 서버 간의 데이터 교환을 대체할 수단을 만들었고, HTTP/2.0 프로토콜의 기초로 기여하게 된다.

### 개선 사항

- **이진 프로토콜**
    
    더 이상 브라우저 내에서 사용자가 읽을 수 없고, 만들어낼 수 없다. 
    
- 다중화 프로토콜로, 병렬 요청이 동일한 커넥션 상에서 다루어질 수 있다. 순서를 제거해 HTTP/1.x 프로토콜의 제약사항인 **순서대로 전송되어야 하는 요청을 해소**했다.
- **헤더 압축**
    
    전송된 데이터의 중복과 불필요한 오버헤드를 제거하여, 연속된 요청 사이의 유사한 내용이 들어있는 헤더를 압축시켰다.
    
    [허프만 코딩 압축 알고리즘](https://ko.wikipedia.org/wiki/%ED%97%88%ED%94%84%EB%A8%BC_%EB%B6%80%ED%98%B8%ED%99%94)을 사용하여 HPACK 압축 형식을 가진다.
    
- **서버 푸쉬**
    
    서버 푸쉬라는 매커니즘으로 클라이언트 캐시를 필요하게 될 데이터로 채워넣을 수 있게 한다.
    
    HTTP/1.1에서는 클라이언트가 서버에 요청을 해야 파일을 다운로드할 수 있는데, HTTP/2에서는 클라이언트 요청 없이 서버가 바로 리소스를 푸쉬할 수 있다. 
    
    ⇒ **`양방향 통신, 동적인 웹이 가능`**
    
    ex) html 파일 안에 css,js파일을 html을 읽으면서 안에 있는 파일 또한 서버에서 푸시하여 클라이언트에게 준다.
    
    - SSE(Server Sent Events)
    - WebSocket
- **멀티플렉싱**
    
    여러 개의 스트림을 사용하여 송수신한다.
    
    애플리케이션에서 받아온 메세지를 독립된 프레임으로 조각내서 서로 송수신한 이후에 다시 조립하여 데이터를 주고 받는다. 단일 연결을 통해 병렬로 여러 요청/응답을 주고받을 수 있기에 HOL Blocking문제를 해결할 수 있다.
    
    또한, 특정 스트림의 패킷이 손실되었다고 해도 해당 스트림에만 영향을 미치고 나머지 스트림은 정상적으로 동작한다.
    

## HTTPS

HTTP/2는 HTTPS 위에서 동작한다. HTTPS는 애플리케이션 계층과 전송 계층 사이 신뢰 계층인 SSL/TLS계층을 넣은 신뢰할 수 있는 HTTP 요청이라는 뜻이다. ⇒ **통신 암호화**

## HTTP/3.0

TCP 위에서 돌아가는 HTTP/2와 달리 UDP기반의 QUIC 계층 위에서 돌아간다. HTTP/2에서는 TCP를 사용하기 때문에 초기 연결 시 3-웨이 핸드쉐이크를 진행하여 초기 연결 설정 시간이 있다. HTTP/3에서는 UDP 기반의 QUIC를 사용하기 때문에 3-웨이 핸드쉐이크를 사용하지 않고, 첫 연결 설정시 1-RTT만 소요된다.

[HTTP/3는 왜 UDP를 선택한 것일까?](https://evan-moon.github.io/2019/10/08/what-is-http3/)

[[WEB] 🌐 HTTP 3.0 통신 기술 - 자신있게 이해하기](https://inpa.tistory.com/entry/WEB-%F0%9F%8C%90-HTTP-30-%ED%86%B5%EC%8B%A0-%EA%B8%B0%EC%88%A0-%EC%9D%B4%EC%A0%9C%EB%8A%94-%ED%99%95%EC%8B%A4%ED%9E%88-%EC%9D%B4%ED%95%B4%ED%95%98%EC%9E%90)
