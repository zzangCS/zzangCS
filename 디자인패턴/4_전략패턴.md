
## 1.1.3 전략 패턴 (Strategy Pattern)

- 객체의 행위를 직접 수정하지 않고 전략만 변경하여 상호 교체가 가능하게 만드는 패턴
- 특정 계열의 알고리즘을 정의하고 캡술화하여 서로 교환해서 사용
- 하나의 클래스가 많은 행동들을 정의하고, 클래스 연산 안에서 복잡한 다중 조건문의 모습을 취하는 경우 사용
- 컨텍스트 (Context) : 알고리즘을 실행해야할 때 해당 알고리즘과 연결된 전략 객체의 메소드 호출
- 전략 (Strategy) : 알고리즘, 행위, 동작을 객체로 정의한 구현체

#### 예제

- 커피 종류에 대한 전략 클래스 생성
- 커피 종류에 대한 전략을 통해 커피를 주문하도록 Context를 정의한다.

```javascript
class Americano {
  order() {
    console.log('아메리카노 주세요.');
  }
}

class VanillaLatte {
  order() {
    console.log('바닐라 라떼 주세요.');
  }
}

class CoffeeContext {
  setCoffee(coffee) {
    this._stragegy = coffee;
  }
}

const coffee = new CoffeeContext();

coffee.setCoffee(new VanillaLatte());
coffee.order(); // 바닐라 라떼 주세요.


// 전략만 바꾸면 다른 종류의 커피를 주문할 수 있음
coffee.setCoffee(new Americano());
coffee.order(); // 아메리카노 주세요.
```

#### 장점

1. 메소드 중복 해결 -> 알고리즘 재사용 가능
2. 컨텍스트의 코드 변경 없이 새로운 전략 추가 (조건문 감소)
3. 전략을 사용하는 Composition 클래스에서 서브클래싱을 하지 않아도 됨

#### 단점

1. 객체 수 증가 (전략으로 생성하는 객체)
2. 각 전략들 사이의 차이점을 알아야함