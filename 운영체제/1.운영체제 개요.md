# 운영체제 개요

# 운영체제란?

**컴퓨터 하드웨어 바로 위에 설치**되어 사용자 및 다른 모든 소프트웨어와 하드웨어를 연결하는 소프트웨어 계층

![Untitled](%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20%E1%84%80%E1%85%A2%E1%84%8B%E1%85%AD%206a0d6a27d59a453b9a4ea05bc7ba6bd9/Untitled.png)

- 컴퓨터 시스템을 **편리하게 사용할 수 있는 환경 제공**
    - 하드웨어를 직접 다루는 복잡한 부분을 운영체제가 대행
    - 동시 사용자/프로그램들이 각각 독자적 컴퓨터에서 수행되는 것 같은 환상 제공
- 컴퓨터 시스템의 **자원을 효율적으로 관리 ⇒ 판단하는 능력**
    - cpu, 메모리, I/O 장치를 효율적으로 관리
    - 주어진 자원으로 최대한의 성능을 내도록 → 효율성
    - 특정 사용자/프로그램의 지나친 불이익이 발생하지 않도록 → 형평성

⇒ 컴퓨터가 꺼지기 전까지 운영체제는 돌아간다.

## 운영체제 기능

⇒ 컴퓨터가 꺼지기 전까지 운영체제는 돌아간다.

- **가장 핵심적인 부분(협의의 운영체제) : 커널 - 메모리에 상주**
- 광의의 운영체제 : 커널 뿐 아니라 각종 주변 시스템 유틸리티를 포함한 개념

직접 디스크가 처리하는게 아니라 앞에 붙어있는 컨트롤러에 부탁한다.

![Untitled](%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20%E1%84%80%E1%85%A2%E1%84%8B%E1%85%AD%206a0d6a27d59a453b9a4ea05bc7ba6bd9/Untitled%201.png)

![Untitled](%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20%E1%84%80%E1%85%A2%E1%84%8B%E1%85%AD%206a0d6a27d59a453b9a4ea05bc7ba6bd9/Untitled%202.png)

## CPU 스케줄링

: 자원을 관리할 때는 **효율성&형평성**을 고려해야 한다.

1. FCFS(First-Come First-Served)
    
    프로세스가 CPU 큐에 도착한 순서대로 처리
    
    ⇒ 효율성 측면에서 좋지 않음
    
2. SJF(Shortest-Job-First) - 가장 적절한 방법
    
    CPU 사용시간이 가장 짧은 프로세스를 제일 먼저 스케줄
    
    ⇒ minimum average waiting time 보장
    
    but, starvation(기아 현상) 발생 가능(효율성은 좋지만 형평성의 문제가 있음)
    
3. RR(Round Robin)
    
    ![Untitled](%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20%E1%84%80%E1%85%A2%E1%84%8B%E1%85%AD%206a0d6a27d59a453b9a4ea05bc7ba6bd9/Untitled%203.png)
    
- 각 프로세스는 동일 크기의 CPU 할당시간을 가짐
- 할당시간이 끝나면 인터럽트가 발생(하드웨어의 지원)하여 프로세스는 CPU를 빼앗기고 CPU 큐의 제일 뒤에 줄을 섬
- n개의 프로세스가 CPU 큐에 있는 경우
    - 어떤 프로세스도 `(n-1)*할당시간` 이상 기다리지 않음
        - n-1인 이유 : 본인 빼고!
    - 대기시간이 프로세스의 CPU 사용시간에 비례

## 메모리 관리

메모리는 휘발성이니까, 전원을 키면 부팅할 때, 하드디스크→메모리로 운영체제가 올라오고 여러 응용프로그램들이 메모리에서 작업시작할 수 있게 된다.

- 메모리는 전원이 꺼지면 사라지는 공간(휘발성)
- 프로세스는 전원이 꺼지면 사라지는 공간(휘발성)
1. 가상메모리에 디스크 파일시스템의 실행파일들을 프로세스로 옮김
    - 디스크 파일시스템은 전원이 꺼져도 저장되어 있는 공간(비휘발성)
2. 필요한 부분만 물리메모리에 올려놓음
3. 쫓겨난 실행파일들은 디스크의 스왑영역으로
    - 디스크 스왑영역은 전원이 꺼져도 저장은 되어 있지만 사용되지 않는 공간(비휘발성 but 사용하진 않는 공간)

![Untitled](%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20%E1%84%80%E1%85%A2%E1%84%8B%E1%85%AD%206a0d6a27d59a453b9a4ea05bc7ba6bd9/Untitled%204.png)

### 어떤 페이지를 스왑영역으로 쫓아낼 것인가?

메모리가 꽉 차면, 어떤 실행파일들부터 스왑영역으로 이동시킬 것인가.

⇒ **페이지 교체 알고리즘**

## 디스크 스케줄링

![Untitled](%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20%E1%84%80%E1%85%A2%E1%84%8B%E1%85%AD%206a0d6a27d59a453b9a4ea05bc7ba6bd9/Untitled%205.png)

디스크 헤드가 이동하면서 해당 트랙을 읽어가는 원리

- **헤드의 이동거리, 시간을 줄이는게 관건! = seek time을 최소화하는 것이 목표**
- seek time = seek distance

### 디스크 접근시간 구성

1. 탐색시간(seek time)
    
    : 헤드를 해당 트랙으로 움직이는데 걸리는 시간
    
2. 회전지연(rotational latency)
    
    : 헤드가 원하는 섹터에 도달하기까지 걸리는 시간
    
3. 전송시간(transfer time)
    
    : 실제 데이터의 전송시간
    

### 디스크 스케줄링 알고리즘

SSTF(shortest seek time first)

![Untitled](%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20%E1%84%80%E1%85%A2%E1%84%8B%E1%85%AD%206a0d6a27d59a453b9a4ea05bc7ba6bd9/Untitled%206.png)

SCAN

![Untitled](%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20%E1%84%80%E1%85%A2%E1%84%8B%E1%85%AD%206a0d6a27d59a453b9a4ea05bc7ba6bd9/Untitled%207.png)

## 저장장치 계층구조와 캐싱

> 빠른 CPU와 느린 I/O 장치간 속도차를 어떻게 극복하지?
> 

![Untitled](%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20%E1%84%80%E1%85%A2%E1%84%8B%E1%85%AD%206a0d6a27d59a453b9a4ea05bc7ba6bd9/Untitled%208.png)

위로 올라갈수록 빠르고, 비싸고, 휘발성(전원을 끄면 내용이 날아감)이다.

**⇒ 속도 차이를 완충하기 위해서**

- primary(executable) : CPU가 직접 실행할 수 있다.
- secondary : CPU가 직접 접근 못하고, 실행하려면 primary에 올려야 한다. (I/O 장치로 구성)

### 플래시 메모리

플래시 메모리는 반도체 장치, 하드디스크는 마그네틱의 기계식 장치

- **플래시 메모리 - 반도체 장치**
- **하드디스크 - 기계식 장치**

![Untitled](%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20%E1%84%80%E1%85%A2%E1%84%8B%E1%85%AD%206a0d6a27d59a453b9a4ea05bc7ba6bd9/Untitled%209.png)

- SSD : 안에 플래시 메모리가 들어가 있음

**특징**

- 전원이 나가도 데이터가 유지됨
- 전력 사용이 적다
- 물리적인 손상이 적다
- 크기가 작고 가볍다
- 쓰기 횟수 제약이 있다
- 데이터가 변질될 수도 있다

⇒ 소프트웨어가 이러한 약점들을 보완해줘야 한다.

## 운영체제 종류

> 서버용, PC용, 스마트디바이스용
> 

서버 - linux

pc - macOS, windows, linux

스마트디바이스 - ios, android + linux 커널

**!! 리눅스는 오픈소스코드여서 소스코드가 공개되어 있다!!**

컴파일하면 바이너리코드가 생성 → 바이너리 보고 컴퓨터가 실행

**리눅스, 안드로이드는 소스가 공개되어 있는 공개 소프트웨어(Open Source Software)이다.**

### 왜 리눅스, 안드로이드는 소스를 오픈할까?

소프트웨어는 독점이 가능한 시장이다. 한 소프트웨어가 좋으면 장악을 해버린다. 어차피 독점이 불가능하다면 소스를 공개해버리겠다!

→ 리눅스가 소스를 공개한 이유

리눅스 코드를 수정해서 사용하다보니 점유율이 생김. 점점 더 사용하는 인원이 많아지게 됨.
